# Copyright 2015-2016 Intel Corporation.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# The 1st value of SUPPORTED_TUNNELING_PROTO is used as the default
# tunneling protocol for OP2P tests.
SUPPORTED_TUNNELING_PROTO = ['vxlan', 'gre', 'geneve']

#
# Generic test configuration options are described at conf/01_testcases.conf
#

#
# Options specific to integration testcases are described below:
#
# Required for OP2P tests
# "Tunnel Type": ["vxlan"|"gre"|"geneve"]   # Tunnel Type defines tunneling protocol to use.
#                                   # It can be overridden by cli option TUNNEL_TYPE.
#                                   # Values:
#                                   #    "vxlan" - iteration of destination MAC address
#                                   #    "gre" - iteration of destination IP address
#                                   #    "geneve" - iteration of destination UDP port
#                                   # Default value is "vxlan".
#
# bidirectional testing for OP2P is not yet supported.
# TRAFFIC['bidir'] must be set to 'False'.

#
# Common TestSteps parts ("macros")
#

# P2P macros
STEP_VSWITCH_P2P_FLOWS_INIT = [
    ['vswitch', 'add_switch', 'int_br0'],           # STEP 0
    ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 1
    ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 2
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', 'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_P2P_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[2][1]'}],
    ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
    ['vswitch', 'del_switch', 'int_br0'],
]

# PVP and PVVP macros
STEP_VSWITCH_PVP_INIT = [
    ['vswitch', 'add_switch', 'int_br0'],           # STEP 0
    ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 1
    ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 2
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 3    vm1 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 4
]

STEP_VSWITCH_PVP_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[3][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[4][0]'],
    ['vswitch', 'del_switch', 'int_br0'],
]

STEP_VSWITCH_PVP_FLOWS_INIT = STEP_VSWITCH_PVP_INIT + [
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', 'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[3][1]', 'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_PVP_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[4][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[2][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[3][1]'}],
] + STEP_VSWITCH_PVP_FINIT

STEP_VSWITCH_PVVP_INIT = STEP_VSWITCH_PVP_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 5    vm2 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 6
]

STEP_VSWITCH_PVVP_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[5][0]'],  # vm2 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[6][0]'],
] + STEP_VSWITCH_PVP_FINIT

STEP_VSWITCH_PVVP_FLOWS_INIT = STEP_VSWITCH_PVVP_INIT + [
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', 'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', 'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[5][1]', 'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[3][1]', 'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_PVVP_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[4][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[6][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[2][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[5][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[3][1]'}],
] + STEP_VSWITCH_PVVP_FINIT

STEP_VSWITCH_P4VP_INIT = STEP_VSWITCH_PVVP_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 7    vm3 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 8
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 9    vm4 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 10
]

STEP_VSWITCH_P4VP_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[7][0]'],  # vm3 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[8][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[9][0]'],  # vm4 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[10][0]'],
] + STEP_VSWITCH_PVVP_FINIT

STEP_VSWITCH_P4VP_FLOWS_INIT = STEP_VSWITCH_P4VP_INIT + [
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', \
                'actions': ['output:#STEP[7][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[8][1]', \
                'actions': ['output:#STEP[9][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[10][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', \
                'actions': ['output:#STEP[10][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[9][1]', \
                'actions': ['output:#STEP[8][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[7][1]', \
                'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[5][1]', \
                'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[3][1]', \
                'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_P4VP_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0'],
] + STEP_VSWITCH_P4VP_FINIT

STEP_VSWITCH_2PHY_2VM_INIT = STEP_VSWITCH_PVVP_INIT

STEP_VSWITCH_2PHY_2VM_FINIT = STEP_VSWITCH_PVVP_FINIT

STEP_VSWITCH_2_PARALLEL_VM_FLOWS_INIT  = [
            # Setup Flows to reply ICMPv6 and similar packets, so to
            # avoid flooding the internal port with their re-transmissions
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:01', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:02', \
                'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:03', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:04', \
                'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
            # Forward UDP packets depending on dest port
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '0', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '1', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            # Send VM outputs to phy port #2
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_2PHY_4VM_INIT = STEP_VSWITCH_2PHY_2VM_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 7    vm3 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 8
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 9    vm4 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 10
]

STEP_VSWITCH_2PHY_4VM_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[7][0]'],  # vm3 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[8][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[9][0]'],  # vm4 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[10][0]'],
] + STEP_VSWITCH_2PHY_2VM_FINIT

STEP_VSWITCH_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0'],
]

STEP_VSWITCH_4_PARALLEL_VM_FLOWS_INIT = [
            # Setup Flows to reply ICMPv6 and similar packets, so to
            # avoid flooding the internal port with their re-transmissions
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:01', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:02', \
                'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:03', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:04', \
                'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:05', \
                'actions': ['output:#STEP[7][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:06', \
                'actions': ['output:#STEP[8][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:07', \
                'actions': ['output:#STEP[9][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:08', \
                'actions': ['output:#STEP[10][1]'], 'idle_timeout': '0'}],
            # Forward UDP packets depending on dest port
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '0', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '1', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '2', \
                'actions': ['output:#STEP[7][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '3', \
                'actions': ['output:#STEP[9][1]'], 'idle_timeout': '0'}],
            # Send VM outputs to phy port #2
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[8][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[10][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_2PHY_6VM_INIT = STEP_VSWITCH_2PHY_4VM_INIT + [
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 11   vm5    vhu8
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 12          vhu9
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 13   vm6    vhu10
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 14          vhu11
]

STEP_VSWITCH_6_PARALLEL_VM_FLOWS_INIT = STEP_VSWITCH_4_PARALLEL_VM_FLOWS_INIT + [
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:09', \
                'actions': ['output:#STEP[11][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:0a', \
                'actions': ['output:#STEP[12][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:0b', \
                'actions': ['output:#STEP[13][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:0c', \
                'actions': ['output:#STEP[14][1]'], 'idle_timeout': '0'}],
            # Forward UDP packets depending on dest port
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '4', \
                'actions': ['output:#STEP[11][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '5', \
                'actions': ['output:#STEP[13][1]'], 'idle_timeout': '0'}],
            # Send VM outputs to phy port #2
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[12][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[14][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_2PHY_6VM_FINIT = [
            ['vswitch', 'del_port', 'int_br0', '#STEP[11][0]'],  # vm5 ports
            ['vswitch', 'del_port', 'int_br0', '#STEP[12][0]'],
            ['vswitch', 'del_port', 'int_br0', '#STEP[13][0]'],  # vm6 ports
            ['vswitch', 'del_port', 'int_br0', '#STEP[14][0]'],
] + STEP_VSWITCH_2PHY_4VM_FINIT

#
# Definition of integration tests
#
INTEGRATION_TESTS = [
    {
        "Name": "overlay_p2p_mod_tput",
        "Deployment": "ptunp",
        "Tunnel Type": "vxlan",
        "Description": ("Tunneling Throughput RFC2544 Test."
                       "The encap and decap are performed inside the "
                       "virtual switch itself in each direction to avoid "
                       "the need of ingress overlay traffic."),
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_tput",
        "Deployment": "op2p",
        "Tunnel Type": SUPPORTED_TUNNELING_PROTO[0],
        "Tunnel Operation": "encapsulation",
        "Description": "Overlay Encapsulation Throughput RFC2544 Test",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_cont",
        "Deployment": "op2p",
        "Tunnel Type": SUPPORTED_TUNNELING_PROTO[0],
        "Tunnel Operation": "encapsulation",
        "Description": "Overlay Encapsulation RFC2544 Continuous Stream",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_continuous",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_decap_tput",
        "Deployment": "op2p",
        "Tunnel Type": SUPPORTED_TUNNELING_PROTO[0],
        "Tunnel Operation": "decapsulation",
        "Description": "Overlay Decapsulation Throughput RFC2544 Test",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_decap_cont",
        "Deployment": "op2p",
        "Tunnel Type": SUPPORTED_TUNNELING_PROTO[0],
        "Tunnel Operation": "decapsulation",
        "Description": "Overlay Decapsulation RFC2544 Continuous Stream",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_continuous",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "vswitch_add_del_bridge",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete bridge",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_bridges",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete bridges",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_switch', 'int_br1'],
                        ['vswitch', 'del_switch', 'int_br0'],
                        ['vswitch', 'del_switch', 'int_br1'],
                     ]
    },
    {
        "Name": "vswitch_add_del_phy_port",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete physical port",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_phy_ports",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete physical ports",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_vport",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete virtual port",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_vports",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete virtual ports",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_flow",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete flow",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
                        ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_vports_add_del_flow",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch with vports, add and delete flow",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
                        ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_flows",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete flows",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p2p_tput",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and execute RFC2544 throughput test",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     [
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                     ] +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p2p_back2back",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and execute RFC2544 back2back test",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     [
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                     ] +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p2p_cont",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and execute RFC2544 continuous stream test",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     [
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                     ] +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and one vnf",
        "TestSteps": STEP_VSWITCH_PVP_INIT +
                     [
                        ['vnf', 'start'],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FINIT
    },
    {
        "Name": "vswitch_vports_pvp",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch with vports and one vnf",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vnf', 'start'],
                        ['vnf', 'stop'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_pvp_tput",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute RFC2544 throughput test",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp_back2back",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute RFC2544 back2back test",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp_cont",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute RFC2544 continuous stream test",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp_all",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute all test types",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and two vnfs",
        "TestSteps": STEP_VSWITCH_PVVP_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FINIT
    },
    {
        "Name": "vswitch_pvvp_tput",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute RFC2544 throughput test",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp_back2back",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute RFC2544 back2back test",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp_cont",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute RFC2544 continuous stream test",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp_all",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute all test types",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p4vp",
        "Description": "Just configure 4 chained vnfs",
        "Deployment": "clean",
        "TestSteps": STEP_VSWITCH_P4VP_FLOWS_INIT +
        [
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
        ] +
        STEP_VSWITCH_P4VP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p4vp_tput",
        "Description": "4 chained vnfs, execute RFC2544 throughput test",
        "Deployment": "clean",
        "TestSteps": STEP_VSWITCH_P4VP_FLOWS_INIT +
        [
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', \
                'bidir' : 'True'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
        ] +
        STEP_VSWITCH_P4VP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p4vp_back2back",
        "Description": "4 chained vnfs, execute RFC2544 back2back test",
        "Deployment": "clean",
        "TestSteps": STEP_VSWITCH_P4VP_FLOWS_INIT +
        [
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', \
                'bidir' : 'True'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
        ] +
        STEP_VSWITCH_P4VP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p4vp_cont",
        "Description": "4 chained vnfs, execute RFC2544 continuous stream test",
        "Deployment": "clean",
        "TestSteps": STEP_VSWITCH_P4VP_FLOWS_INIT +
        [
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', \
                'bidir' : 'True'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
        ] +
        STEP_VSWITCH_P4VP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p4vp_all",
        "Description": "4 chained vnfs, execute RFC2544 throughput test",
        "Deployment": "clean",
        "TestSteps": STEP_VSWITCH_P4VP_FLOWS_INIT +
        [
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', \
                'bidir' : 'True'}],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', \
                'bidir' : 'True'}],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', \
                'bidir' : 'True'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
        ] +
        STEP_VSWITCH_P4VP_FLOWS_FINIT
    },
    {
      # Topology: 2 Parallel PVP connections
      # To run a Linux bridge as a loopback in the Guest use:
      #     --test-params "GUEST_LOOPBACK=['linux_bridge']" --integration 2pvp_udp_dest_flows
      # or add "Parameters" option to the test definition:
      #     "Parameters" : {'GUEST_LOOPBACK' : ['linux_bridge'],},
        "Name": "2pvp_udp_dest_flows",
        "Description": "RFC2544 Continuous TC with 2 Parallel VMs, flows on UDP Dest Port",
        "Deployment": "clean",
        "Parameters" : {
            "TRAFFIC" : {
                "multistream" : 2,
                "stream_type" : "L4",
            },
        },
        "TestSteps": STEP_VSWITCH_2PHY_2VM_INIT +
            STEP_VSWITCH_2_PARALLEL_VM_FLOWS_INIT + [
            # Start 2 VMs
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'False'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            # Clean up
        ] + STEP_VSWITCH_FLOWS_FINIT +
            STEP_VSWITCH_2PHY_2VM_FINIT
    },
    {
      # Topology: 4 Parallel PVP connections
      # To run a Linux bridge as a loopback in the Guest use:
      #     --test-params "GUEST_LOOPBACK=['linux_bridge']" --integration 4pvp_udp_dest_flows
      # or add "Parameters" option to the test definition:
      #     "Parameters" : {'GUEST_LOOPBACK' : ['linux_bridge'],},
        "Name": "4pvp_udp_dest_flows",
        "Description": "RFC2544 Continuous TC with 4 Parallel VMs, flows on UDP Dest Port",
        "Deployment": "clean",
        "Parameters" : {
            "TRAFFIC" : {
                "multistream" : 4,
                "stream_type" : "L4",
            },
        },
        "TestSteps": STEP_VSWITCH_2PHY_4VM_INIT +
            STEP_VSWITCH_4_PARALLEL_VM_FLOWS_INIT + [
            # Start 4 VMs
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'False'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
            # Clean up
        ] + STEP_VSWITCH_FLOWS_FINIT +
            STEP_VSWITCH_2PHY_4VM_FINIT
    },
    {
      # Topology: 6 Parallel PVP connections
      # To run a Linux bridge as a loopback in the Guest use:
      #     --test-params "GUEST_LOOPBACK=['linux_bridge']" --integration 6pvp_udp_dest_flows
      # or add "Parameters" option to the test definition:
      #     "Parameters" : {'GUEST_LOOPBACK' : ['linux_bridge'],},
        "Name": "6pvp_udp_dest_flows",
        "Description": "RFC2544 Continuous TC with 6 Parallel VMs, flows on UDP Dest Port",
        "Deployment": "clean",
        "Parameters" : {
            "TRAFFIC" : {
                "multistream" : 6,
                "stream_type" : "L4",
            },
        },
        "TestSteps": STEP_VSWITCH_2PHY_6VM_INIT +
            STEP_VSWITCH_6_PARALLEL_VM_FLOWS_INIT + [
            # Start VMs
            ['vnf1', 'start'],
            ['vnf2', 'start'],
            ['vnf3', 'start'],
            ['vnf4', 'start'],
            ['vnf5', 'start'],
            ['vnf6', 'start'],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'False'}],
            ['vnf1', 'stop'],
            ['vnf2', 'stop'],
            ['vnf3', 'stop'],
            ['vnf4', 'stop'],
            ['vnf5', 'stop'],
            ['vnf6', 'stop'],
        ] + STEP_VSWITCH_FLOWS_FINIT +
        STEP_VSWITCH_2PHY_6VM_FINIT
    },
    {
        # Testcase for verification of vHost User NUMA awareness feature
        # introduced in DPDK v2.2. Test case will execute two VNFs, each
        # pinned to different NUMA slot. After that it will verify that
        # QEMU and PMD threads serving its interfaces are co-located
        # at the same NUMA slot.
        #
        # Prerequisites:
        #     * architecture with at least 2 NUMA slots
        #     * OVS with DPDK support and DPDK v2.2 and newer
        #     * OVS configuration utilizing both NUMA slots
        #
        #     Example of OVS configuration valid for DPDK v16.04 and cores
        #     split between NUMA slots as follows:
        #           node 0 cpus: 0 1 2 3 4 5 6 7 8 9
        #           node 1 cpus: 10 11 12 13 14 15 16 17 18 19
        #
        #     VSWITCH_PMD_CPU_MASK = '1010'
        #     VSWITCHD_DPDK_CONFIG = {
        #         'dpdk-init' : 'true',
        #         'dpdk-lcore-mask' : '0x4004',
        #         'pmd-cpu-mask' : 'FF0FF',
        #         'dpdk-socket-mem' : '1024,1024',
        #     }
        #
        "Name": "vhost_numa_awareness",
        "Deployment": "clean",
        "Description": "vSwitch DPDK - verify that PMD threads are served "
                       "by the same NUMA slot as QEMU instances",
        "vSwitch" : "OvsDpdkVhost",
        "TestSteps": STEP_VSWITCH_PVVP_INIT +                                       # STEP 0-6
            [
                # check that at least 2 numa slots are available
                ['tools', 'exec_shell', 'numactl -H', 'available: ([0-9]+)'],       # STEP 7
                ['tools', 'assert', '#STEP[-1][0]>1'],                              # STEP 8
                # store last 2 cores from numa slot 0
                ['tools', 'exec_shell', 'numactl -H', 'node 0 cpus:.*\s+(\\d+) (\\d+)$'], # STEP 9
                # store last 2 cores from numa slot 1
                ['tools', 'exec_shell', 'numactl -H', 'node 1 cpus:.*\s+(\\d+) (\\d+)$'], # STEP 10
                # pin VNF1 to 1st NUMA slot and VNF2 to 2nd NUMA slot
                ['settings', 'setValue', 'GUEST_CORE_BINDING',                      # STEP 11
                    [("#STEP[-2][0][0]", "#STEP[-2][0][1]"),
                     ("#STEP[-1][0][0]", "#STEP[-1][0][1]")]
                ],
                # start 2 VNFs
                ['vnf1', 'start'],                                                  # STEP 12
                ['vnf2', 'start'],                                                  # STEP 13
                # read paths to ovs utilities
                ['settings', 'getValue', 'TOOLS'],                                  # STEP 14
                # check that PMD thread serving VNF1 runs at NUMA slot 0
                ## i.e. get numa slot ID serving dpdhvhostuser0...
                ['tools', 'exec_shell', "sudo #STEP[-1]['ovs-appctl'] "             # STEP 15
                    "dpif-netdev/pmd-rxq-show | "
                    "sed -e '/dpdkvhostuser0/,$d' | tac",
                    'pmd thread numa_id ([0-9])+'
                ],
                ## ...and check that it is NUMA slot 0
                ['tools', 'assert', '#STEP[-1][0]==0'],                             # STEP 16
                # check that PMD thread serving VNF2 runs at NUMA slot 1
                ## i.e. get numa slot ID serving dpdhvhostuser2...
                ['tools', 'exec_shell', "sudo #STEP[-3]['ovs-appctl'] "             # STEP 17
                    "dpif-netdev/pmd-rxq-show | "
                    "sed -e '/dpdkvhostuser2/,$d' | tac",
                    'pmd thread numa_id ([0-9])+'
                ],
                ## ...and check that it is NUMA slot 1
                ['tools', 'assert', '#STEP[-1][0]==1'],                             # STEP 18
                # clean up
                ['vnf2', 'stop'],                                                   # STEP 19
                ['vnf1', 'stop'],                                                   # STEP 20
            ] +
            STEP_VSWITCH_PVVP_FINIT                                                 # STEP 21...
    },
    {
        # Testcase to demonstrate 1 port connection between DUT and IXIA traffic
        # generator. Testcase will enforce IxNet trafficgen and it will configure
        # both ports to the value of TRAFFICGEN_IXIA_PORT1 to indicate one port
        # connection.
        # Please note, that it is essential to ensure that TRAFFICGEN_IXIA_PORT1
        # is physically connected to the first NIC from WHITELIST_NICS list.
        "Name": "ixnet_pvp_tput_1nic",
        "Deployment": "clean",
        "Description": "PVP Scenario with 1 port towards IXIA",
        "Parameters" : {
            "TRAFFICGEN" : "IxNet",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                # we are using one port, thus it's already a bidir connection
                "bidir" : "False",
            },
        },
        "TestSteps": [
            ['vswitch', 'add_switch', 'int_br0'],           # STEP 0
            ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 1
            ['vswitch', 'add_vport', 'int_br0'],            # STEP 2
            ['vswitch', 'add_vport', 'int_br0'],            # STEP 3
            ['vswitch', 'add_flow', 'int_br0',
             {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'],
              'idle_timeout': '0'}],                        # STEP 4
            ['vswitch', 'add_flow', 'int_br0',
             {'in_port': '#STEP[3][1]', 'actions': ['output:#STEP[1][1]'],
              'idle_timeout': '0'}],                        # STEP 5
            ['vnf', 'start'],                               # STEP 6
            ['settings', 'getValue', 'TRAFFICGEN_IXIA_PORT1'], # STEP 7
            ['settings', 'setValue', 'TRAFFICGEN_IXIA_PORT2', '#STEP[-1]'],
            ['trafficgen', 'send_traffic', {}],
            ['vswitch', 'dump_flows', 'int_br0'],
            ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
            ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[3][1]'}],
            ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
            ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
            ['vswitch', 'del_port', 'int_br0', '#STEP[3][0]'],
            ['vswitch', 'del_switch', 'int_br0'],
        ]
    },
    #
    # VPP tests used by VERIFY and MERGE jobs by OPNFV Jenkins
    #
    {
        "Name": "vswitch_vports_add_del_connection_vpp",
        "Deployment": "clean",
        "Description": "VPP: vSwitch - configure switch with vports, add and delete connection",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_connection', 'int_br0', '#STEP[1][0]', '#STEP[2][0]', True],
                        ['vswitch', 'dump_connections', 'int_br0'],
                        ['vswitch', 'del_connection', 'int_br0', '#STEP[1][0]', '#STEP[2][0]', True],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    #
    # END of VPP tests used by VERIFY and MERGE jobs by OPNFV Jenkins
    #
]

# Example of TC definition with exact vSwitch, VNF and TRAFFICGEN values.
#    {
#        "Name": "ovs_vanilla_linux_bridge_pvp_cont",
#        "Deployment": "clean",
#        "Description": "vSwitch - configure OVS Vanilla, QemuVirtioNet with linux bridge and execute continuous stream test",
#        "vSwitch" : "OvsVanilla",
#        "VNF" : "QemuVirtioNet",
#        "Trafficgen": "IxNet",
#        "Parameters": {"GUEST_LOOPBACK" : ["linux_bridge"],},
#        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
#                     [
#                        ['vnf', 'start'],
#                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
#                        ['vnf', 'stop'],
#                     ] +
#                     STEP_VSWITCH_PVP_FLOWS_FINIT
#    },
