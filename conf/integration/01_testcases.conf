# Copyright 2015-2018 Intel Corporation, Tieto and others.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Generic test configuration options are described at conf/01_testcases.conf
#

#
# Options specific to integration testcases are described below:
#
# Required for OP2P tests
# "Tunnel Type": ["vxlan"|"gre"|"geneve"]   # Tunnel Type defines tunneling protocol to use.
#                                   # It can be overridden by cli option TUNNEL_TYPE.
#                                   # Values:
#                                   #    "vxlan" - iteration of destination MAC address
#                                   #    "gre" - iteration of destination IP address
#                                   #    "geneve" - iteration of destination UDP port
#                                   # Default value is "vxlan".
#
# bidirectional testing for OP2P is not yet supported.
# TRAFFIC['bidir'] must be set to 'False'.

#
# Common TestSteps parts ("macros")
#

# P2P macros
STEP_VSWITCH_P2P_INIT = [
    ['vswitch', 'add_switch', 'int_br0'],           # STEP 0
    ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 1
    ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 2
]

STEP_VSWITCH_P2P_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
    ['vswitch', 'del_switch', 'int_br0'],
]

STEP_VSWITCH_P2P_FLOWS_INIT = STEP_VSWITCH_P2P_INIT + [
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', 'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_P2P_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[2][1]'}],
] + STEP_VSWITCH_P2P_FINIT

# PVP and PVVP macros
STEP_VSWITCH_PVP_INIT = STEP_VSWITCH_P2P_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 3    vm1 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 4
]

STEP_VSWITCH_PVP_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[3][0]'],  # vm1 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[4][0]'],
] + STEP_VSWITCH_P2P_FINIT

STEP_VSWITCH_PVP_FLOWS_INIT = STEP_VSWITCH_PVP_INIT + [
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', 'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[3][1]', 'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_PVP_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[4][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[2][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[3][1]'}],
] + STEP_VSWITCH_PVP_FINIT

STEP_VSWITCH_PVVP_INIT = STEP_VSWITCH_PVP_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 5    vm2 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 6
]

STEP_VSWITCH_PVVP_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[5][0]'],  # vm2 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[6][0]'],
] + STEP_VSWITCH_PVP_FINIT

STEP_VSWITCH_PVVP_FLOWS_INIT = STEP_VSWITCH_PVVP_INIT + [
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', 'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', 'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[5][1]', 'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
    ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[3][1]', 'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_PVVP_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[4][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[6][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[2][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[5][1]'}],
    ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[3][1]'}],
] + STEP_VSWITCH_PVVP_FINIT

STEP_VSWITCH_P4VP_INIT = STEP_VSWITCH_PVVP_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 7    vm3 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 8
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 9    vm4 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 10
]

STEP_VSWITCH_P4VP_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[7][0]'],  # vm3 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[8][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[9][0]'],  # vm4 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[10][0]'],
] + STEP_VSWITCH_PVVP_FINIT

STEP_VSWITCH_P4VP_FLOWS_INIT = STEP_VSWITCH_P4VP_INIT + [
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', \
                'actions': ['output:#STEP[7][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[8][1]', \
                'actions': ['output:#STEP[9][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[10][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[2][1]', \
                'actions': ['output:#STEP[10][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[9][1]', \
                'actions': ['output:#STEP[8][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[7][1]', \
                'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[5][1]', \
                'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[3][1]', \
                'actions': ['output:#STEP[1][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_P4VP_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0'],
] + STEP_VSWITCH_P4VP_FINIT

STEP_VSWITCH_2PHY_2VM_INIT = STEP_VSWITCH_PVVP_INIT

STEP_VSWITCH_2PHY_2VM_FINIT = STEP_VSWITCH_PVVP_FINIT

STEP_VSWITCH_2_PARALLEL_VM_FLOWS_INIT  = [
            # Setup Flows to reply ICMPv6 and similar packets, so to
            # avoid flooding the internal port with their re-transmissions
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:01', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:02', \
                'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:03', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:04', \
                'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
            # Forward UDP packets depending on dest port
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '0', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '1', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            # Send VM outputs to phy port #2
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_2PHY_4VM_INIT = STEP_VSWITCH_2PHY_2VM_INIT + [
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 7    vm3 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 8
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 9    vm4 ports
    ['vswitch', 'add_vport', 'int_br0'],            # STEP 10
]

STEP_VSWITCH_2PHY_4VM_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[7][0]'],  # vm3 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[8][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[9][0]'],  # vm4 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[10][0]'],
] + STEP_VSWITCH_2PHY_2VM_FINIT

STEP_VSWITCH_FLOWS_FINIT = [
    ['vswitch', 'dump_flows', 'int_br0'],
    ['vswitch', 'del_flow', 'int_br0'],
]

STEP_VSWITCH_4_PARALLEL_VM_FLOWS_INIT = [
            # Setup Flows to reply ICMPv6 and similar packets, so to
            # avoid flooding the internal port with their re-transmissions
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:01', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:02', \
                'actions': ['output:#STEP[4][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:03', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:04', \
                'actions': ['output:#STEP[6][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:05', \
                'actions': ['output:#STEP[7][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:06', \
                'actions': ['output:#STEP[8][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:07', \
                'actions': ['output:#STEP[9][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:08', \
                'actions': ['output:#STEP[10][1]'], 'idle_timeout': '0'}],
            # Forward UDP packets depending on dest port
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '0', \
                'actions': ['output:#STEP[3][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '1', \
                'actions': ['output:#STEP[5][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '2', \
                'actions': ['output:#STEP[7][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '3', \
                'actions': ['output:#STEP[9][1]'], 'idle_timeout': '0'}],
            # Send VM outputs to phy port #2
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[4][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[6][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[8][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[10][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_2PHY_6VM_INIT = STEP_VSWITCH_2PHY_4VM_INIT + [
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 11   vm5    vhu8
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 12          vhu9
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 13   vm6    vhu10
            ['vswitch', 'add_vport', 'int_br0'],        # STEP 14          vhu11
]

STEP_VSWITCH_6_PARALLEL_VM_FLOWS_INIT = STEP_VSWITCH_4_PARALLEL_VM_FLOWS_INIT + [
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:09', \
                'actions': ['output:#STEP[11][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:0a', \
                'actions': ['output:#STEP[12][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:0b', \
                'actions': ['output:#STEP[13][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', \
                {'priority': '1', 'dl_src': '00:00:00:00:00:0c', \
                'actions': ['output:#STEP[14][1]'], 'idle_timeout': '0'}],
            # Forward UDP packets depending on dest port
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '4', \
                'actions': ['output:#STEP[11][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', \
                'dl_type': '0x0800', 'nw_proto': '17', 'udp_dst': '5', \
                'actions': ['output:#STEP[13][1]'], 'idle_timeout': '0'}],
            # Send VM outputs to phy port #2
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[12][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
            ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[14][1]', \
                'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
]

STEP_VSWITCH_2PHY_6VM_FINIT = [
    ['vswitch', 'del_port', 'int_br0', '#STEP[11][0]'],  # vm5 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[12][0]'],
    ['vswitch', 'del_port', 'int_br0', '#STEP[13][0]'],  # vm6 ports
    ['vswitch', 'del_port', 'int_br0', '#STEP[14][0]'],
] + STEP_VSWITCH_2PHY_4VM_FINIT

#
# Definition of integration tests
#
INTEGRATION_TESTS = [
    {
        "Name": "overlay_p2p_mod_tput",
        "Deployment": "ptunp",
        "Tunnel Type": "vxlan",
        "Description": ("Tunneling Throughput RFC2544 Test."
                       "The encap and decap are performed inside the "
                       "virtual switch itself in each direction to avoid "
                       "the need of ingress overlay traffic."),
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_tput",
        "Deployment": "op2p",
        "Tunnel Operation": "encapsulation",
        "Description": "Overlay Encapsulation Throughput RFC2544 Test",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_cont",
        "Deployment": "op2p",
        "Tunnel Operation": "encapsulation",
        "Description": "Overlay Encapsulation RFC2544 Continuous Stream",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_continuous",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_decap_tput",
        "Deployment": "op2p",
        "Tunnel Operation": "decapsulation",
        "Description": "Overlay Decapsulation Throughput RFC2544 Test",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "overlay_p2p_decap_cont",
        "Deployment": "op2p",
        "Tunnel Operation": "decapsulation",
        "Description": "Overlay Decapsulation RFC2544 Continuous Stream",
        "Parameters": {
            "TRAFFICGEN_IXNET_TCL_SCRIPT" : "ixnetrfc2544v2.tcl",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_continuous",
                "bidir" : "False",
            },
        },
    },
    {
        "Name": "vswitch_add_del_bridge",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete bridge",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_bridges",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete bridges",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_switch', 'int_br1'],
                        ['vswitch', 'del_switch', 'int_br0'],
                        ['vswitch', 'del_switch', 'int_br1'],
                     ]
    },
    {
        "Name": "vswitch_add_del_phy_port",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete physical port",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_phy_ports",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete physical ports",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_vport",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete virtual port",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_vports",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete virtual ports",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_flow",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete flow",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'add_phy_port', 'int_br0'],
                        ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
                        ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_vports_add_del_flow",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch with vports, add and delete flow",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_flow', 'int_br0', {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'], 'idle_timeout': '0'}],
                        ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_add_del_flows",
        "Deployment": "clean",
        "Description": "vSwitch - add and delete flows",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p2p_tput",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and execute RFC2544 throughput test",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     [
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                     ] +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p2p_back2back",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and execute RFC2544 back2back test",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     [
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                     ] +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p2p_cont",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and execute RFC2544 continuous stream test",
        "TestSteps": STEP_VSWITCH_P2P_FLOWS_INIT +
                     [
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                     ] +
                     STEP_VSWITCH_P2P_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and one vnf",
        "TestSteps": STEP_VSWITCH_PVP_INIT +
                     [
                        ['vnf', 'start'],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FINIT
    },
    {
        "Name": "vswitch_vports_pvp",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch with vports and one vnf",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vnf', 'start'],
                        ['vnf', 'stop'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    {
        "Name": "vswitch_pvp_tput",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute RFC2544 throughput test",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp_back2back",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute RFC2544 back2back test",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp_cont",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute RFC2544 continuous stream test",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvp_all",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, vnf and execute all test types",
        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
                     [
                        ['vnf', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf', 'stop'],
                     ] +
                     STEP_VSWITCH_PVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch and two vnfs",
        "TestSteps": STEP_VSWITCH_PVVP_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FINIT
    },
    {
        "Name": "vswitch_pvvp_tput",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute RFC2544 throughput test",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp_back2back",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute RFC2544 back2back test",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp_cont",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute RFC2544 continuous stream test",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_pvvp_all",
        "Deployment": "clean",
        "Description": "vSwitch - configure switch, two chained vnfs and execute all test types",
        "TestSteps": STEP_VSWITCH_PVVP_FLOWS_INIT +
                     [
                        ['vnf1', 'start'],
                        ['vnf2', 'start'],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', 'bidir' : 'True'}],
                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
                        ['vnf1', 'stop'],
                        ['vnf2', 'stop'],
                     ] +
                     STEP_VSWITCH_PVVP_FLOWS_FINIT
    },
    {
        "Name": "vswitch_p4vp",
        "Description": "Just configure 4 chained vnfs",
        "Deployment": "pvvp4",
        "TestSteps": []
    },
    {
        "Name": "vswitch_p4vp_tput",
        "Description": "4 chained vnfs, execute RFC2544 throughput test",
        "Deployment": "pvvp4",
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', \
                'bidir' : 'True'}],
        ]
    },
    {
        "Name": "vswitch_p4vp_back2back",
        "Description": "4 chained vnfs, execute RFC2544 back2back test",
        "Deployment": "pvvp4",
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', \
                'bidir' : 'True'}],
        ]
    },
    {
        "Name": "vswitch_p4vp_cont",
        "Description": "4 chained vnfs, execute RFC2544 continuous stream test",
        "Deployment": "pvvp4",
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', \
                'bidir' : 'True'}],
        ]
    },
    {
        "Name": "vswitch_p4vp_all",
        "Description": "4 chained vnfs, execute RFC2544 throughput test",
        "Deployment": "pvvp4",
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_throughput', \
                'bidir' : 'True'}],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_back2back', \
                'bidir' : 'True'}],
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', \
                'bidir' : 'True'}],
        ]
    },
    {
      # Topology: 2 Parallel PVP connections
      # To run a Linux bridge as a loopback in the Guest use:
      #     --test-params "GUEST_LOOPBACK=['linux_bridge']" --integration 2pvp_udp_dest_flows
      # or add "Parameters" option to the test definition:
      #     "Parameters" : {'GUEST_LOOPBACK' : ['linux_bridge'],},
        "Name": "2pvp_udp_dest_flows",
        "Description": "RFC2544 Continuous TC with 2 Parallel VMs, flows on UDP Dest Port",
        "Deployment": "pvpv2",
        "Parameters" : {
            "TRAFFIC" : {
                "multistream" : 2,
                "stream_type" : "L4",
            },
        },
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'False'}],
        ]
    },
    {
      # Topology: 4 Parallel PVP connections
      # To run a Linux bridge as a loopback in the Guest use:
      #     --test-params "GUEST_LOOPBACK=['linux_bridge']" --integration 4pvp_udp_dest_flows
      # or add "Parameters" option to the test definition:
      #     "Parameters" : {'GUEST_LOOPBACK' : ['linux_bridge'],},
        "Name": "4pvp_udp_dest_flows",
        "Description": "RFC2544 Continuous TC with 4 Parallel VMs, flows on UDP Dest Port",
        "Deployment": "pvpv4",
        "Parameters" : {
            "TRAFFIC" : {
                "multistream" : 4,
                "stream_type" : "L4",
            },
        },
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'False'}],
        ]
    },
    {
      # Topology: 6 Parallel PVP connections
      # To run a Linux bridge as a loopback in the Guest use:
      #     --test-params "GUEST_LOOPBACK=['linux_bridge']" --integration 6pvp_udp_dest_flows
      # or add "Parameters" option to the test definition:
      #     "Parameters" : {'GUEST_LOOPBACK' : ['linux_bridge'],},
        "Name": "6pvp_udp_dest_flows",
        "Description": "RFC2544 Continuous TC with 6 Parallel VMs, flows on UDP Dest Port",
        "Deployment": "pvpv6",
        "Parameters" : {
            "TRAFFIC" : {
                "multistream" : 6,
                "stream_type" : "L4",
            },
        },
        "TestSteps":
        [
            ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'False'}],
        ]
    },
    {
        # Testcase for verification of vHost User NUMA awareness feature
        # introduced in DPDK v2.2. Test case will execute two VNFs, each
        # pinned to different NUMA slot. After that it will verify that
        # QEMU and PMD threads serving its interfaces are co-located
        # at the same NUMA slot.
        #
        # Prerequisites:
        #     * architecture with at least 2 NUMA slots
        #     * OVS with DPDK support and DPDK v2.2 and newer
        #     * OVS configuration utilizing both NUMA slots
        #
        #     Example of OVS configuration valid for DPDK v16.04 and cores
        #     split between NUMA slots as follows:
        #           node 0 cpus: 0 1 2 3 4 5 6 7 8 9
        #           node 1 cpus: 10 11 12 13 14 15 16 17 18 19
        #
        #     VSWITCH_PMD_CPU_MASK = '1010'
        #     VSWITCHD_DPDK_CONFIG = {
        #         'dpdk-init' : 'true',
        #         'dpdk-lcore-mask' : '0x4004',
        #         'pmd-cpu-mask' : 'FF0FF',
        #         'dpdk-socket-mem' : '1024,1024',
        #     }
        #
        "Name": "vhost_numa_awareness",
        "Deployment": "clean",
        "Description": "vSwitch DPDK - verify that PMD threads are served "
                       "by the same NUMA slot as QEMU instances",
        "vSwitch" : "OvsDpdkVhost",
        "TestSteps": STEP_VSWITCH_PVVP_INIT +                                       # STEP 0-6
            [
                # check that at least 2 numa slots are available
                ['tools', 'exec_shell', 'numactl -H', 'available: ([0-9]+)'],       # STEP 7
                ['tools', 'assert', '#STEP[-1][0]>1'],                              # STEP 8
                # store last 2 cores from numa slot 0
                ['tools', 'exec_shell', 'numactl -H', 'node 0 cpus:.*\s+(\\d+) (\\d+)$'], # STEP 9
                # store last 2 cores from numa slot 1
                ['tools', 'exec_shell', 'numactl -H', 'node 1 cpus:.*\s+(\\d+) (\\d+)$'], # STEP 10
                # pin VNF1 to 1st NUMA slot and VNF2 to 2nd NUMA slot
                ['settings', 'setValue', 'GUEST_CORE_BINDING',                      # STEP 11
                    [("#STEP[-2][0][0]", "#STEP[-2][0][1]"),
                     ("#STEP[-1][0][0]", "#STEP[-1][0][1]")]
                ],
                # start 2 VNFs
                ['vnf1', 'start'],                                                  # STEP 12
                ['vnf2', 'start'],                                                  # STEP 13
                # read paths to ovs utilities
                ['settings', 'getValue', 'TOOLS'],                                  # STEP 14
                # check that PMD thread serving VNF1 runs at NUMA slot 0
                ## i.e. get numa slot ID serving dpdhvhostuser0...
                ['tools', 'exec_shell', "sudo #STEP[-1]['ovs-appctl'] "             # STEP 15
                    "dpif-netdev/pmd-rxq-show | "
                    "sed -e '/dpdkvhostuser0/,$d' | tac",
                    'pmd thread numa_id ([0-9])+'
                ],
                ## ...and check that it is NUMA slot 0
                ['tools', 'assert', '#STEP[-1][0]==0'],                             # STEP 16
                # check that PMD thread serving VNF2 runs at NUMA slot 1
                ## i.e. get numa slot ID serving dpdhvhostuser2...
                ['tools', 'exec_shell', "sudo #STEP[-3]['ovs-appctl'] "             # STEP 17
                    "dpif-netdev/pmd-rxq-show | "
                    "sed -e '/dpdkvhostuser2/,$d' | tac",
                    'pmd thread numa_id ([0-9])+'
                ],
                ## ...and check that it is NUMA slot 1
                ['tools', 'assert', '#STEP[-1][0]==1'],                             # STEP 18
                # clean up
                ['vnf2', 'stop'],                                                   # STEP 19
                ['vnf1', 'stop'],                                                   # STEP 20
            ] +
            STEP_VSWITCH_PVVP_FINIT                                                 # STEP 21...
    },
    {
        # Testcase to demonstrate 1 port connection between DUT and IXIA traffic
        # generator. Testcase will enforce IxNet trafficgen and it will configure
        # both ports to the value of TRAFFICGEN_IXIA_PORT1 to indicate one port
        # connection.
        # Please note, that it is essential to ensure that TRAFFICGEN_IXIA_PORT1
        # is physically connected to the first NIC from WHITELIST_NICS list.
        "Name": "ixnet_pvp_tput_1nic",
        "Deployment": "clean",
        "Description": "PVP Scenario with 1 port towards IXIA",
        "Parameters" : {
            "TRAFFICGEN" : "IxNet",
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_throughput",
                # we are using one port, thus it's already a bidir connection
                "bidir" : "False",
            },
        },
        "TestSteps": [
            ['vswitch', 'add_switch', 'int_br0'],           # STEP 0
            ['vswitch', 'add_phy_port', 'int_br0'],         # STEP 1
            ['vswitch', 'add_vport', 'int_br0'],            # STEP 2
            ['vswitch', 'add_vport', 'int_br0'],            # STEP 3
            ['vswitch', 'add_flow', 'int_br0',
             {'in_port': '#STEP[1][1]', 'actions': ['output:#STEP[2][1]'],
              'idle_timeout': '0'}],                        # STEP 4
            ['vswitch', 'add_flow', 'int_br0',
             {'in_port': '#STEP[3][1]', 'actions': ['output:#STEP[1][1]'],
              'idle_timeout': '0'}],                        # STEP 5
            ['vnf', 'start'],                               # STEP 6
            ['settings', 'getValue', 'TRAFFICGEN_IXIA_PORT1'], # STEP 7
            ['settings', 'setValue', 'TRAFFICGEN_IXIA_PORT2', '#STEP[-1]'],
            ['trafficgen', 'send_traffic', {}],
            ['vswitch', 'dump_flows', 'int_br0'],
            ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[1][1]'}],
            ['vswitch', 'del_flow', 'int_br0', {'in_port': '#STEP[3][1]'}],
            ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
            ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
            ['vswitch', 'del_port', 'int_br0', '#STEP[3][0]'],
            ['vswitch', 'del_switch', 'int_br0'],
        ]
    },
    #
    # VPP tests used by VERIFY and MERGE jobs by OPNFV Jenkins
    #
    {
        "Name": "vswitch_version_vpp",
        "Deployment": "clean",
        "Description": "VPP: vSwitch - determine VPP version and fail if it is not possible.",
        "vSwitch" : "VppDpdkVhost",
        "TestSteps": [
                        ['vswitch', 'run_vppctl', ['show', 'version', 'verbose'], '|Version:\s+(v\d+\.\d+)'],
                        ['tools', 'assert', 'len(#STEP[-1][0])'],
                     ]
    },
    {
        "Name": "vswitch_vports_add_del_connection_vpp",
        "Deployment": "clean",
        "Description": "VPP: vSwitch - configure switch with vports, add and delete connection",
        "vSwitch" : "VppDpdkVhost",
        "TestSteps": [
                        ['vswitch', 'add_switch', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_vport', 'int_br0'],
                        ['vswitch', 'add_connection', 'int_br0', '#STEP[1][0]', '#STEP[2][0]', True],
                        ['vswitch', 'dump_connections', 'int_br0'],
                        ['vswitch', 'del_connection', 'int_br0', '#STEP[1][0]', '#STEP[2][0]', True],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[1][0]'],
                        ['vswitch', 'del_port', 'int_br0', '#STEP[2][0]'],
                        ['vswitch', 'del_switch', 'int_br0'],
                     ]
    },
    #
    # END of VPP tests used by VERIFY and MERGE jobs by OPNFV Jenkins
    #

    #
    # Examples of functional testcases with traffic capture validation
    #
    # Capture Example 1 - Traffic capture inside VM (PVP scenario)
    # This TestCase will modify VLAN ID set by the traffic generator to the new value.
    # Correct VLAN ID settings is verified by inspection of captured frames.
    {
        "Name": "capture_pvp_modify_vid",
        "Deployment": "pvp",
        "Description": "Test and verify VLAN ID modification by Open vSwitch",
        "Parameters" : {
            "VSWITCH" : "OvsDpdkVhost", # works also for Vanilla OVS
            "TRAFFICGEN_DURATION" : 5,
            "TRAFFIC" : {
                "traffic_type" : "rfc2544_continuous",
                "frame_rate" : 100,
                'vlan': {
                    'enabled': True,
                    'id': 8,
                    'priority': 1,
                    'cfi': 0,
                },
            },
            "GUEST_LOOPBACK" : ['linux_bridge'],
        },
        "TestSteps": [
            # replace original flows with vlan ID modification
            ['!vswitch', 'add_flow', 'br0', {'in_port': '1', 'actions': ['mod_vlan_vid:4','output:3']}],
            ['!vswitch', 'add_flow', 'br0', {'in_port': '2', 'actions': ['mod_vlan_vid:4','output:4']}],
            ['vswitch', 'dump_flows', 'br0'],
            # verify that received frames have modified vlan ID
            ['VNF0', 'execute_and_wait', 'tcpdump -i eth0 -c 5 -w dump.pcap vlan 4 &'],
            ['trafficgen', 'send_traffic',{}],
            ['!VNF0', 'execute_and_wait', 'tcpdump -qer dump.pcap vlan 4 2>/dev/null | wc -l','|^(\d+)$'],
            ['tools', 'assert', '#STEP[-1][0] == 5'],
        ],
    },
]
# Capture Example 2 - Setup with 2 NICs, where traffic is captured after it is
# processed by NIC under the test (2nd NIC). See documentation for further details.
# This TestCase will strip VLAN headers from traffic sent by the traffic generator.
# The removal of VLAN headers is verified by inspection of captured frames.
#
# NOTE: This setup expects a DUT with two NICs with two ports each. First NIC is
# connected to the traffic generator (standard VSPERF setup). Ports of a second NIC
# are interconnected by a patch cable. PCI addresses of all four ports have to be
# properly configured in the WHITELIST_NICS parameter.
_CAPTURE_P2P2P_OVS_ACTION = ''
_CAPTURE_P2P2P_SETUP = [
        # restore original NICS configuration, so we can refer to NICS elements
        ['settings', 'resetValue', 'WHITELIST_NICS'],
        ['settings', 'resetValue', 'NICS'],
        # create and configure two bridges to forward traffic through NIC under
        # the test and back to the traffic generator
        # 1st bridge:
        ['vswitch', 'add_switch', 'br0'],
        ['tools', 'exec_shell', 'sudo ip addr flush dev $NICS[0]["device"]'],
        ['tools', 'exec_shell', 'sudo ip link set dev $NICS[0]["device"] up'],
        ['tools', 'exec_shell', '$TOOLS["ovs-vsctl"] add-port br0 $NICS[0]["device"]'],
        ['tools', 'exec_shell', 'sudo $TOOLS["bind-tool"] --bind igb_uio $NICS[3]["pci"]'],
        ['tools', 'exec_shell', '$TOOLS["ovs-vsctl"] add-port br0 dpdk0 -- '
                                'set Interface dpdk0 type=dpdk options:dpdk-devargs=$NICS[3]["pci"]'],
        ['tools', 'exec_shell', '$TOOLS["ovs-ofctl"] add-flow br0 in_port=1,action='
                                '$_CAPTURE_P2P2P_OVS_ACTION,output:2'],
        # 2nd bridge:
        ['vswitch', 'add_switch', 'br1'],
        ['tools', 'exec_shell', 'sudo ip addr flush dev $NICS[2]["device"]'],
        ['tools', 'exec_shell', 'sudo ip link set dev $NICS[2]["device"] up'],
        ['tools', 'exec_shell', '$TOOLS["ovs-vsctl"] add-port br1 $NICS[2]["device"]'],
        ['tools', 'exec_shell', 'sudo ip addr flush dev $NICS[1]["device"]'],
        ['tools', 'exec_shell', 'sudo ip link set dev $NICS[1]["device"] up'],
        ['tools', 'exec_shell', '$TOOLS["ovs-vsctl"] add-port br1 $NICS[1]["device"]'],
        ['vswitch', 'add_flow', 'br1', {'in_port': '1', 'actions': ['output:2']}],
        # log flow details
        ['vswitch', 'dump_flows', 'br0'],
        ['vswitch', 'dump_flows', 'br1'],
]
INTEGRATION_TESTS += [
    {
        "Name": "capture_p2p2p_strip_vlan_ovs",
        "Deployment": "clean",
        "Description": "P2P Continuous Stream",
        "Parameters" : {
            "_CAPTURE_P2P2P_OVS_ACTION" : 'strip_vlan',
            "TRAFFIC" : {
                "bidir" : "False",
                "traffic_type" : "rfc2544_continuous",
                "frame_rate" : 100,
                'l2': {
                    'srcmac': "ca:fe:00:00:00:00",
                    'dstmac': "00:00:00:00:00:01"
                },
                'vlan': {
                    'enabled': True,
                    'id': 8,
                    'priority': 1,
                    'cfi': 0,
                },
            },
            # suppress DPDK configuration, so physical interfaces are not bound to DPDK driver
            'WHITELIST_NICS' : [],
            'NICS' : [],
        },
        "TestSteps": _CAPTURE_P2P2P_SETUP + [
            # capture traffic after processing by NIC under the test (after possible egress HW offloading)
            ['tools', 'exec_shell_background', 'tcpdump -i $NICS[2]["device"] -c 5 -w capture.pcap '
                                               'ether src $TRAFFIC["l2"]["srcmac"]'],
            ['trafficgen', 'send_traffic', {}],
            ['vswitch', 'dump_flows', 'br0'],
            ['vswitch', 'dump_flows', 'br1'],
            # there must be 5 captured frames...
            ['tools', 'exec_shell', 'tcpdump -r capture.pcap | wc -l', '|^(\d+)$'],
            ['tools', 'assert', '#STEP[-1][0] == 5'],
            # ...but no vlan headers
            ['tools', 'exec_shell', 'tcpdump -r capture.pcap vlan | wc -l', '|^(\d+)$'],
            ['tools', 'assert', '#STEP[-1][0] == 0'],
        ],
    },
    # Capture Example 3 - Traffic capture by traffic generator.
    # This TestCase uses OVS flow to add VLAN tag with given ID into every
    # frame send by traffic generator. Correct frame modificaiton is verified by
    # inspection of packet capture received by T-Rex.
    {
        "Name": "capture_p2p_add_vlan_ovs_trex",
        "Deployment": "clean",
        "Description": "OVS: Test VLAN tag modification and verify it by traffic capture",
        "vSwitch" : "OvsDpdkVhost", # works also for Vanilla OVS
        "Parameters" : {
            "TRAFFICGEN" : "Trex",
            "TRAFFICGEN_TREX_LEARNING_MODE" : True,
            "TRAFFIC" : {
                "traffic_type" : "burst",
                "frame_rate" : 100,
                "burst_size" : 5,
                # enable capture of five RX frames
                'capture': {
                    'enabled': True,
                    'tx_ports' : [],
                    'rx_ports' : [1],
                    'count' : 5,
                },
            },
        },
        "TestSteps" : STEP_VSWITCH_P2P_INIT + [
            # replace standard L2 flows by flows, which will add VLAN tag with ID 3
            ['!vswitch', 'add_flow', 'int_br0', {'in_port': '1', 'actions': ['mod_vlan_vid:3','output:2']}],
            ['!vswitch', 'add_flow', 'int_br0', {'in_port': '2', 'actions': ['mod_vlan_vid:3','output:1']}],
            ['vswitch', 'dump_flows', 'int_br0'],
            ['trafficgen', 'send_traffic', {}],
            ['trafficgen', 'get_results'],
            # verify that captured frames have vlan tag with ID 3
            ['tools', 'exec_shell', 'tcpdump -qer $RESULTS_PATH/#STEP[-1][0]["capture_rx"] vlan 3 '
                                    '2>/dev/null | wc -l', '|^(\d+)$'],
            # number of received frames with expected VLAN id must match the number of captured frames
            ['tools', 'assert', '#STEP[-1][0] == 5'],
        ] + STEP_VSWITCH_P2P_FINIT,
    },
    #
    # End of examples of functional testcases with traffic capture validation
    #
]

# Example of TC definition with exact vSwitch, VNF and TRAFFICGEN values.
#    {
#        "Name": "ovs_vanilla_linux_bridge_pvp_cont",
#        "Deployment": "clean",
#        "Description": "vSwitch - configure OVS Vanilla, QemuVirtioNet with linux bridge and execute continuous stream test",
#        "vSwitch" : "OvsVanilla",
#        "VNF" : "QemuVirtioNet",
#        "Trafficgen": "IxNet",
#        "Parameters": {"GUEST_LOOPBACK" : ["linux_bridge"],},
#        "TestSteps": STEP_VSWITCH_PVP_FLOWS_INIT +
#                     [
#                        ['vnf', 'start'],
#                        ['trafficgen', 'send_traffic', {'traffic_type' : 'rfc2544_continuous', 'bidir' : 'True'}],
#                        ['vnf', 'stop'],
#                     ] +
#                     STEP_VSWITCH_PVP_FLOWS_FINIT
#    },
